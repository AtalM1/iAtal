\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage[english]{babel}
\usepackage[autolanguage]{numprint}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\lstset{keywordstyle=\color{blue}, stringstyle=\color{brown}}
\usepackage{graphicx}
\usepackage{hyperref}
\graphicspath{{./img/}}
\DeclareGraphicsExtensions{.png,.jpg}
\usepackage{libertine}

\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}
%opening
\title{iAtal Manual}
\author{Agathe \textsc{Moll\'e} \and Gr\'egoire \textsc{Jadi} \and Hugo \textsc{Mougard} \and Joseph \textsc{Lark} 
\and Lo\"\i c \textsc{Jankowiak} \and No\'emi \textsc{Sala\"un} \and R\'emi \textsc{Bois}}
\date{\today}

\begin{document}

\maketitle

\tableofcontents



\section*{Preface}
This manual documents the use of the application iAtal.  As a
reference manual, it will describe the different features of the
application. It includes a tutorial in order to help the
beginners. You will also find an help to compile, install and run the
program.  All the specific terms will be explained in a glossary.
  %TODO : blablabla, skip chapters blabla
  
\section*{Introduction}
The application described here is named iAtal. It's a rover behaviour
simulation platform.  A rover is a robot which executes some tasks in
a self-sufficient way, and in an unknown environment.  It owns sensors
that help it to feel and understand its close environment and
actuators that allow it to move and to interact with the map.


The iAtal program deal with maps in TMX format. Those maps can
be created with Tiled %TODO ref, see chapter...%
or manually.  You can also create your own exploration strategy, your
rover's sensors and actuators, thanks to Python.  Those features will
be detailed further.

\section{How to run iAtal}

\subsection{Requirements}
% TODO : Attentes de l’application en terme d’architecture machine et
% de logiciels pré-installés

\subsection{Installing iAtal}
% TODO

\subsection{Running iAtal}
% TODO : façons correctes de lancer iAtal...
There are two different ways to run the program :
\begin{itemize}
\item Whithout any option :
\begin{verbatim}
	.\ui
\end{verbatim}
  The program will then start empty and you will have to set the map
  and the rover strategy later. (See chapter...)
  
\item Directly with a personnalised map and/or exploration strategy :
\begin{verbatim}
	.\ui [-h|--help] [{-m|--map} map_path] [{-s|--strategy} strat_path]
\end{verbatim}
  Description of these options :
  \begin{itemize}
  \item \verb!-h! or \verb!--help! : Produce help message
  \item \verb!-m map_path! or \verb!--map map_path! : Set the path to
    the map to use. It must be a file in TMX format (.tmx) (See
    chapter...)
  \item \verb!-s strat_path! or \verb!--strategy strat_path! : Set the
    path to the strategy to use. It must be a file in Python (.py). It
    requires a map to be set too. (See chapter...)
  \end{itemize}
\end{itemize}

\section{Importing a map}

\subsection{Creating a TMX map}

To create your own map, it is strongly recommended to use the software
Tiled (ref, doc).  Tiled generates XML files wich are on the TMX
format, supported by iAtal. However, you should know that iAtal map
loader is limited to maps with 4 layers or less. Those layers are :
\begin{itemize}
 \item underground
 \item ground
 \item object
\end{itemize}
\label{avaibleLayers}

iAtal only understands TMX maps with separated tilesets. The tilesets
are described in TSX files (.tsx). In order to have some clear
resources, you should use one tileset by layer, and give it the name of
. For exemple, if your
map is designed with the layers \textit{ground} and \textit{objects},
you need to use a tileset for the ground tiles, and another one for
the objects tiles.

%TODO : limitations map par super mogzor

\subsection{Loading your map}

Once your map is created, you just have to save it, and to load it in
iAtal.


\section{Defining a robot and a strategy with Python}

This section will describe how to define a robot and a strategy to
apply to the selected map. The user will have to implement some
functions in order to describe how the robot will behave and some of
its features. These functions have to be located in a file which will
be given to the application. The table \ref{tab:PyMandatoryFunc}
presents the mandatory functions to use in the strategy file.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|c|p{10cm}|}
      \hline
      Name & Purpose \\
      \hline
      robot\_init & Sets the start position, the direction faced by the
      robot and the sprites used to represent it \\
      \hline
      strat & Describes an iteration of the strategy used. Sensors and
      actuators are used here. The robot may move or perform some
      actions in each iteration. \\
      \hline
      isEnded & Function returning True when the strategy is finished
      (the robot completed its job) or False if more iterations are to
      come.\\ 
      \hline 
    \end{tabular}
    \caption{\label{tab:PyMandatoryFunc} The mandatory functions}
  \end{center}
\end{table}

\subsection{Defining a robot with robot\_init}

The robot\_init function sets some informations such as the direction
faced by the robot at start, the position of the robot at start, and
the sprites used to draw the robot. These 3 actions use the global
map\_ variable. These three actions should be performed (or else the
program may be malfunctionning), but some other actions could be
performed such as the description and initialization of the sensors
and actuators of your robot. You could also decide to give some
extra-features to your robot such as a battery-state, this is the
right place to define it, semantically (defining your actuators,
sensors or extra-features somewhere else in the file is still
possible).

We will now see the basic actions that must be performed and some
example of what you can do.

\subsubsection{Where the robot starts}

This action is \emph{mandatory}. You have to specify where your robot
starts on the map. You have to use the following function :

\begin{lstlisting}[language=Python]
map_.setPosition(xPosition, yPosition)
\end{lstlisting}

The xPosition (resp. yPosition) corresponds to the abscissa
(resp. ordinate) where the robot will be placed at start. These
coordinates refer to the TMX map loaded. The (0,0) box is located on
the top-left of the TMX map.

You also have to specify in which direction the robot watches. Only
maps with 4 directions are currently supported. These directions are
defined by these pairs :


\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|}
  \hline
  Pair & Meaning \\
  \hline
  (1,0) & East \\
  (0,-1) & North \\
  (-1,0) & West \\
  (0,1) & South \\
  \hline
\end{tabular} 
\caption{\label{tab:Pypairs} The avaible pairs to describe a
  direction}
\end{center}
\end{table}


You have to use the following function which is \emph{mandatory} :

\begin{lstlisting}[language=Python]
map_.setPosition(x,y)
\end{lstlisting}

Where (x,y) is one of the pairs presented in the table \ref{tab:Pypairs}.

\subsubsection{What the robot looks like}

In order to represent the robot on the map, you have to give an image
uri which will reprensent it. Since your robot can face 4 different
directions, it is asked to give 4 images, one for each direction the
robot can face. However, you can put 4 times the same picture.

The order for the pictures is north, south, east, west.

You have to use the following function wich is \emph{mandatory} :

\begin{lstlisting}[language=Python]
map_.setRobotImage(northImg, southImg, eastImg, westImg)
\end{lstlisting}

Where northImg (resp. southImg, eastImg, westImg) corresponds to the
image to use when the robot faces north (resp. south, east, west).

\subsubsection{Sensors}

You have to describe the robot's sensors. A sensor is a feature that
gives the possibility to your robot to have information on its
environment. Even if you can instantiate and use a sensor from
anywhere, it is highly recommended to declare it in the robot\_init()
function (or in a subfunction called by robot\_init()).

A sensor can get an information about a tile at a fixed range, and on
a precise layer. You can find the list of the avaible layers in
section \ref{avaibleLayers} on page \pageref{avaibleLayers}.

For example, it can have access to the tile right in front of the
robot (range 1), and sense the Object layer (enums.Level.Object).

To declare a sensor, you may use the following syntax :

\begin{lstlisting}[language=Python]
  global mySensor
  mySensor = sensor(map_,enums.Level.Ground,2)
\end{lstlisting}

Where enums.Level.Object is part of the avaible layers, 2 is the range
of the sensor (it could be 1, 3, or any positive integer). In this
example, the sensor gets the tile on the Ground layer at a distance of
2 tiles ahead of the robot.

Of course, it is recommended to use better names for your
sensors. Here, we could have called it groundSensor2.

\subsubsection{Actuators}

You have to describe the robot's actuators. An actuator is a feature
that gives the possibility to your robot to modify its
environment. Even if you can instantiate and use an actuator from
anywhere, it is highly recommended to declare it in the robot\_init()
function (or in a subfunction called by robot\_inti()).

An actuator can modify a tile at a fixed range, on a precise layer and
in a definite way. You can find the list of the avaible layers in
section \ref{avaibleLayers} on page \pageref{avaibleLayers}. An actuator replaces a tile by another
tile. The new tile must be defined in the tileset of the map. Its name
is used as the description of the tile.

To declare an actuator, you may use the following syntax :

\begin{lstlisting}[language=Python]
  global myActuator
  myActuator = actuator(map_,enums.Level.Object,1, ``toto'')
\end{lstlisting}

Where enums.Level.Object is part of the avaible layers, 1 is the range
of the actuator (it could be 2, 3, or any positive integer) and toto
is the new tile that will replace the current one. In this example,
when an myActuator is activated, it replaces the tile in front of the
robot on the Object layer by a tile named ``toto'' which must me
described in the tileset used in the map.


\subsubsection{The compass}

The compass is another type of sensor wich is provided by the
application. Even if you could emulate a compass with python by
remembering in which direction you started, and updating your current
direction each time you turn, the compass sensor allows you to get
your current direction at any time.

You can define a new compass by using this syntax :

\begin{lstlisting}[language=Python]
  global compassSensor
  compassSensor = compass(map_)
\end{lstlisting}


\subsubsection{Extending your robot abilities}

Of course, you can add many features to your robot. You could decide
to extend the sensors and actuators with a battery state, and updating
it each time you use one of these.

You could also add a memory to your robot, so it can remember the
paths it took.

You are free and encouraged to extend your robot abilities so it
reflects as much as possible the abilities and constraints of a real
robot.

\subsection{Defining a strategy with strat}

As mentioned above, the editable strat function is the procedure that
the robot will follow for one iteration of the overall strategy.  That
is to say, defining the sensors, actuators of other available actions
the robot will use and how, from the tile it is currently on.

Some variables can be memorized in order to change the behavior of the
robot for a given iteration of the strategy, but every step of the
strategy must be defined by the strat function.

\subsubsection{Using the sensors and the actuators}

The sensors and actuators are called in the strategy by adding
.activate() to the method, for instance
\begin{lstlisting}[language=Python]
  groundSensor.activate()
\end{lstlisting}
will return the information given by the ground sensor.

This is and has to be the only way for the robot to get any
information about the map.

\subsubsection{Some useful functions}

Other functions than the sensors and actuators are available, but they
can't be defined as such because they interact with the robot instead
of the map. These are the basic movement functions to turn left
(turnLeft), turn right (turnRight) and move one tile ahead (walk).

From these basic functions it is possible to build new useful methods,
for instance moving two tiles ahead could be defined by two iterations
of the basic walk function.

Of course, and as it is said before, you can implement many more
extended methods this way.

\subsection{Specifying the end with isEnded}

Unless you want to create an infinite loop, your strategy has to have
an end. You can set the end of the strategy by using the ended
variable to ``True'':

\begin{lstlisting}[language=Python]
  global ended
  ended = True
\end{lstlisting}

This strategy ending flag is tested when the iteration is over, so
that the program will stop the strategy procedure when it is set to
``True''.

You may want to use this variable with a condition, so that it will
only trigger the end of the strategy on a given iteration.

\end{document}
